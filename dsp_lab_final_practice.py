# -*- coding: utf-8 -*-
"""DSP_LAB_FINAL_PRACTICE.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xnJUNXS4dYaNzELITy-8TVLkW80RE0Ai

MD. Samin Hossain Utsho

ID : 1803027

Lab Conducted by : Faruk Sir (CSE Department,RUET)

# **DSP LAB 01**

Analog signal Plotting

Sampling

Quantization

Unit Sample Sequence

Unit Step Sequence

Unit Ramp Sequence
"""

# Take an analog signal
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.pyplot import style

#define continuous time signal => pseudo analog
t = np.arange(0,11)
x = (0.85)**t #exponential

#plotting the signal
plt.figure(figsize = (12,6))
plt.suptitle('Analog Signal')
#style.use('dark_background')
plt.plot(t,x,linewidth = 3, label = 'x(t) = (0.85)^t')
plt.xlabel('t',fontsize = 15)
plt.ylabel('Amplitude',fontsize = 15)
plt.axis([0,10,0,1])
plt.legend(fontsize = 20)
plt.xticks([0,1,2,3,4,5,6,7,8,9,10])
plt.yticks([0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0])
plt.show()

# sampling and plotting the sampled signal

#plotting the signal

plt.figure(figsize = (12,6))
plt.suptitle('Sampling')
#style.use('dark_background')
plt.plot(t,x,linewidth = 3, label = 'x(t) = (0.85)^t')
plt.xlabel('t',fontsize = 15)
plt.ylabel('Amplitude',fontsize = 15)

n = t

plt.axis([0,10,0,1])
plt.legend(fontsize = 20)
plt.xticks([0,1,2,3,4,5,6,7,8,9,10])
plt.yticks([0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0])

markerline,stemlines,baseline = plt.stem(n,x,label = 'x(t) = (0.85)^t')
plt.setp(stemlines,'linewidth' , 3)
plt.xlabel('n',fontsize = 15)
plt.ylabel('Amplitude',fontsize = 15)
plt.legend(fontsize = 20)
plt.show()

# quantization

plt.figure(figsize = (12,8))
plt.suptitle('Quantized')
#style.use('dark_background')


plt.xlabel('t',fontsize = 15)
plt.ylabel('Amplitude',fontsize = 15)


markerline,stemlines,baseline = plt.stem(n,x,label = 'x(t) = (0.85)^t')
plt.setp(stemlines,'linewidth' , 3)

plt.xticks([0,1,2,3,4,5,6,7,8,9,10])
plt.yticks([0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0])

plt.xlabel('n',fontsize = 15)
plt.ylabel('Range Of Quantizer',fontsize = 15)
#plt.legend(fontsize = 20)
plt.axhline(y = 0.1,xmin = 0,xmax = 10,color = 'r',linewidth = 3.0)
plt.axhline(y = 0.2,xmin = 0,xmax = 10,color = 'r',linewidth = 3.0)
plt.axhline(y = 0.3,xmin = 0,xmax = 10,color = 'r',linewidth = 3.0)
plt.axhline(y = 0.4,xmin = 0,xmax = 10,color = 'r',linewidth = 3.0)
plt.axhline(y = 0.5,xmin = 0,xmax = 10,color = 'r',linewidth = 3.0)
plt.axhline(y = 0.6,xmin = 0,xmax = 10,color = 'r',linewidth = 3.0)
plt.axhline(y = 0.7,xmin = 0,xmax = 10,color = 'r',linewidth = 3.0)
plt.axhline(y = 0.8,xmin = 0,xmax = 10,color = 'r',linewidth = 3.0)
plt.axhline(y = 0.9,xmin = 0,xmax = 10,color = 'r',linewidth = 3.0)
plt.axhline(y = 1.0,xmin = 0,xmax = 10,color = 'r',linewidth = 3.0)


plt.show()

print('Non-Quantized Value ',x)
print(len(x))
xq = np.around(x,1)
print(xq)

#plotting the quantized signal ....
# quantization

plt.figure(figsize = (12,8))
plt.suptitle('Quantized')
#style.use('dark_background')


plt.xlabel('t',fontsize = 15)
plt.ylabel('Amplitude',fontsize = 15)


markerline,stemlines,baseline = plt.stem(n,xq,label = 'x(t) = (0.85)^t')
plt.setp(stemlines,'linewidth' , 3)

plt.xticks([0,1,2,3,4,5,6,7,8,9,10])
plt.yticks([0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0])

plt.xlabel('n',fontsize = 15)
plt.ylabel('Range Of Quantizer',fontsize = 15)
#plt.legend(fontsize = 20)
plt.axhline(y = 0.1,xmin = 0,xmax = 10,color = 'r',linewidth = 3.0)
plt.axhline(y = 0.2,xmin = 0,xmax = 10,color = 'r',linewidth = 3.0)
plt.axhline(y = 0.3,xmin = 0,xmax = 10,color = 'r',linewidth = 3.0)
plt.axhline(y = 0.4,xmin = 0,xmax = 10,color = 'r',linewidth = 3.0)
plt.axhline(y = 0.5,xmin = 0,xmax = 10,color = 'r',linewidth = 3.0)
plt.axhline(y = 0.6,xmin = 0,xmax = 10,color = 'r',linewidth = 3.0)
plt.axhline(y = 0.7,xmin = 0,xmax = 10,color = 'r',linewidth = 3.0)
plt.axhline(y = 0.8,xmin = 0,xmax = 10,color = 'r',linewidth = 3.0)
plt.axhline(y = 0.9,xmin = 0,xmax = 10,color = 'r',linewidth = 3.0)
plt.axhline(y = 1.0,xmin = 0,xmax = 10,color = 'r',linewidth = 3.0)


plt.show()

#plotting the quantized signal ....
# quantization

plt.figure(figsize = (12,8))
plt.suptitle('Discrete time signal')
#style.use('dark_background')


plt.xlabel('t',fontsize = 15)
plt.ylabel('Amplitude',fontsize = 15)


markerline,stemlines,baseline = plt.stem(n,xq,label = 'x(t) = (0.85)^t')
plt.setp(stemlines,'linewidth' , 3)

plt.xticks([0,1,2,3,4,5,6,7,8,9,10])
plt.yticks([0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0])

plt.xlabel('n',fontsize = 15)
plt.ylabel('Range Of Quantizer',fontsize = 15)

plt.show()

"""** Plotting basic signals**"""

#Defining the range of the sequence axis
n = np.arange(-10,11)

#Unit sample sequence
unit_sample_sequence = np.zeros_like(n)
unit_sample_sequence[n==0] = 1


#Unit Step sequence
unit_step = np.heaviside(n,1)

#Unit ramp sequence
unit_ramp = np.maximum(n,0)

#Plotting the signal.
fig, axs = plt.subplots(3,1,figsize=(8,8) )

axs[0].stem(n, unit_sample_sequence)
axs[0].set_title('Unit Sample Sequence')


axs[1].stem(n, unit_step)
axs[1].set_title('Unit Step Sequence')



axs[2].stem(n, unit_ramp)
axs[2].set_title('Unit Ramp Sequence')

plt.tight_layout()
plt.show()

for i in range(0,10,2):
  if i%2 ==0:
    print(i)

def rokon():
  food_item = 'pizza'

  return food_item

"""#**DSP LAB 02**

Application of convolution
  ----> Signal Denoising

**Original Signal + Noise** ---> **Noisy Signal** ----(filter)---> **Filtered Signal** -----(filter)----> **Double filtered signal.....**

**Homework**
Sampling Theorem
Minimum Sampling Rate (Nyquist Rate)
"""

# Take an analog signal

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.pyplot import style

#Generating a plotting X1
x1 = np.array([1,2,2,1,1])
n1 = np.array([0,1,2,3,4])
plt.figure(figsize = (20,10))
style.use('dark_background')

plt.subplot(2,2,1)
markerline,stemlines,baseline = plt.stem(n1,x1,label = 'x1')
plt.setp(stemlines,'linewidth' , 3)
plt.legend(fontsize = 20)

#Generating a plotting X2
x2 = np.array([3,2,1])
n2 = np.array([0,1,2])
plt.figure(figsize = (20,10))
style.use('dark_background')

plt.subplot(2,2,2)
markerline,stemlines,baseline = plt.stem(n2,x2,label = 'x2')
plt.setp(stemlines,'linewidth' , 3)
plt.legend(fontsize = 20)


#Again plotting on position 3

plt.figure(figsize = (20,10))
style.use('dark_background')

plt.subplot(2,2,3)
markerline,stemlines,baseline = plt.stem(n1,x1,label = 'x1')
plt.setp(stemlines,'linewidth' , 3)
plt.legend(fontsize = 20)


#Plotting folded/flipped of x2
fold_x2 = x2[::-1]
n3 = np.array([-2,-1,0])
plt.subplot(2,2,4)
markerline,stemlines,baseline = plt.stem(n3,fold_x2,label = 'Folded x2')
plt.setp(stemlines,'linewidth' , 3)
plt.legend(fontsize = 20)

xn = np.array([1,2,3,1])
hn = np.array([1,2,1,-1])
yn = np.convolve(xn,hn,mode = 'full')
print(yn)
plt.stem(yn)
plt.show()

xn = np.array([1,2,3,1])
hn = np.array([1,2,1,-1])
len_x = len(xn)
len_h = len(hn)
mat  = np.zeros((len_x,len_h))

sum = np.zeros(len_x+len_h)

for i in range(len(hn)) :
  for j in range(len(xn)) :
     mat[i][j] = hn[i]*xn[j]





print(mat)
print(sum[1])

"""Application of convolution

Signal Denoising
"""

#Create an Artificial Signal

Srate = 256 #Hz
t = np.arange(0,3,1/Srate)
n_points = len(t)
print(n_points)
print(t)

#Create a noiseless Signal
x = np.sin(2*np.pi*2*t)

#Create a random noise
noise = 5*np.random.randn(n_points)

#Adding Noise to original signal
noise_signal = x + noise

plt.figure(figsize = (20,10))
style.use('dark_background')
plt.plot(t,x,label = 'Original Signal')
plt.legend(fontsize = 30)
plt.show()

plt.figure(figsize = (20,10))
style.use('dark_background')
plt.plot(t,noise_signal,label = 'Noisy Signal')
plt.legend(fontsize = 30)
plt.show()

#Plotting Discrete time noisy signal
plt.figure(figsize = (20,10))
style.use('dark_background')
plt.stem(t,noise_signal,label = 'Noisy Signal')
plt.legend(fontsize = 30)
plt.show()

# Design a basic Filte /kernel /impulse
filter = 2*np.ones(50)/10.0
print(filter)

#Basic Filtering by convolution
filtered_signal = np.convolve(noise_signal,filter,mode = 'full')
#Plotting Discrete time noisy signal
plt.figure(figsize = (20,10))
style.use('dark_background')
plt.plot(filtered_signal,label = 'Filtered Signal')
plt.legend(fontsize = 30)
plt.show()

#Basic Filtering by convolution
double_filtered_signal = np.convolve(filtered_signal,filter,mode = 'full')
#Plotting Discrete time noisy signal
plt.figure(figsize = (20,10))
style.use('dark_background')
plt.plot(double_filtered_signal,label = 'Double Filtered Signal')
plt.legend(fontsize = 30)
plt.show()

#Basic Filtering by convolution
double_filtered_signal = np.convolve(filtered_signal,filter,mode = 'full')
#Plotting Discrete time noisy signal
plt.figure(figsize = (20,10))
style.use('dark_background')
plt.stem(double_filtered_signal,label = 'Double Filtered Signal')
plt.legend(fontsize = 30)
plt.show()

#Basic Filtering by convolution
Triple_filtered_signal = np.convolve(double_filtered_signal,filter,mode = 'full')
#Plotting Discrete time noisy signal
plt.figure(figsize = (20,10))
style.use('dark_background')
plt.plot(Triple_filtered_signal,label = 'Triple Filtered Signal')
plt.legend(fontsize = 30)
plt.show()

#Basic Filtering by convolution
Triple_filtered_signal = np.convolve(double_filtered_signal,filter,mode = 'full')
#Plotting Discrete time noisy signal
plt.figure(figsize = (20,10))
style.use('dark_background')
plt.stem(Triple_filtered_signal,label = 'Triple Filtered Signal')
plt.legend(fontsize = 30)
plt.show()

# Find The origin of convolve signal and compute convolution by loop/manual process



"""#**DSP LAB 03**   (Z-TransFormation)"""

import numpy as np
import matplotlib.pyplot as plt

def plot_pole_zero_diagram(poles,zeros):
  fig,ax = plt.subplots()
  ax.plot(np.real(poles),np.imag(poles),'rx',markersize = 10,label = 'Poles')
  ax.plot(np.real(zeros),np.imag(zeros),'bo',markersize = 10,label = 'Zeros')


  #SET PLOT ATTRIBUTES
  ax.axhline(0,color = 'black',linewidth = 0.5)
  ax.axvline(0,color = 'black',linewidth = 0.5)
  ax.grid(True,which = 'both',linestyle = '--',linewidth = 0.5)
  ax.legend()
  ax.set_xlabel('Real')
  ax.set_ylabel('Imaginary')
  ax.set_title('Pole-Zero Diagram')

#Set plot limits

  ax.set_xlim([-2,2])
  ax.set_ylim([-2,2])
  plt.show()



#Driver Code

poles = [-.5+.5j,-0.5-0.5j,-1.0]
zeros = [0.2j,-0.2j]

plot_pole_zero_diagram(poles,zeros)

import numpy as np
import matplotlib.pyplot as plt

def plot_pole_zero_diagram(poles, zeros):
    fig, ax = plt.subplots()

    # Plotting poles
    ax.plot(np.real(poles), np.imag(poles), 'rx', markersize=10, label='Poles')

    # Plotting zeros
    ax.plot(np.real(zeros), np.imag(zeros), 'bo', markersize=10, label='Zeros')

    # Set plot attributes
    ax.axhline(0, color='black', linewidth=0.5)
    ax.axvline(0, color='black', linewidth=0.5)
    ax.grid(True, which='both', linestyle='--', linewidth=0.5)
    ax.legend()
    ax.set_xlabel('Real')
    ax.set_ylabel('Imaginary')
    ax.set_title('Pole-Zero Diagram')

    # Set plot limits
    ax.set_xlim([-2, 2])
    ax.set_ylim([-2, 2])

    plt.show()

# Example usage
poles = [-0.5 + 0.5j, -0.5 - 0.5j, -1.0]
zeros = [0.2j, -0.2j]

plot_pole_zero_diagram(poles, zeros)



# Discussion of interpretation
print("Interpretation of Pole-Zero Plot:")
print("- Poles represent the system's resonances or modes of decay.")
print("- Zeros represent the frequencies at which the system's output becomes zero.")
print("- System stability can be determined by checking if all poles lie within the unit circle (|z| < 1).")
print("- Frequency response can be deduced from the pole-zero plot, where zeros indicate the presence of peaks or notches in the response.")

import numpy as np
import matplotlib.pyplot as plt

def z_transform(signal, n):

    N = len(signal)
    Z = np.zeros(N, dtype=complex)
    roc = []

    for k in range(N):
        Z[k] = np.sum(signal * np.exp(-1j * 2 * np.pi * n * k / N))
        roc.append(np.abs(Z[k]))

    return Z, roc

# Example usage
signal = [1, 2, 3, 4, 5]
n = np.arange(len(signal))

Z, roc = z_transform(signal, n)

# Plotting ROC
plt.stem(n, roc, use_line_collection=True)
plt.xlabel('n')
plt.ylabel('|Z|')
plt.title('Region of Convergence (ROC) Plot')
plt.grid(True, linestyle='--', linewidth=0.5)
plt.show()

# Printing Z-transform values
print("Z-transform values:")
for i, z in enumerate(Z):
    print("Z[{}]: {}".format(i, z))

import numpy as np
import matplotlib.pyplot as plt

def z_transform(signal, n):

    N = len(signal)
    Z = np.zeros(N, dtype=complex)

    for k in range(N):
        Z[k] = np.sum(signal * np.exp(-1j * 2 * np.pi * n * k / N))

    roc = "Entire z-plane"
    if np.abs(Z).any():
        roc = "ROC: |Z| < {}".format(np.max(np.abs(Z)))

    return Z, roc

# Example usage
signal = [1, 2, 3, 4, 5]
n = np.arange(len(signal))

Z, roc = z_transform(signal, n)

# Plotting ROC
fig, ax = plt.subplots()
circle = plt.Circle((0, 0), radius=np.max(np.abs(Z)), edgecolor='r', facecolor='none')
ax.add_patch(circle)
plt.xlim(-np.max(np.abs(Z))-1, np.max(np.abs(Z))+1)
plt.ylim(-np.max(np.abs(Z))-1, np.max(np.abs(Z))+1)
plt.xlabel('Real')
plt.ylabel('Imaginary')
plt.title('Region of Convergence (ROC)')
plt.grid(True, linestyle='--', linewidth=0.5)
plt.gca().set_aspect('equal', adjustable='box')
plt.show()

# Printing Z-transform values
print("Z-transform values:")
for i, z in enumerate(Z):
    print("Z[{}]: {}".format(i, z))

# Printing ROC
print("\nRegion of Convergence:")
print(roc)

import numpy as np
import matplotlib.pyplot as plt

def z_transform_signal(signal):

    N = len(signal)
    Z = np.zeros(N, dtype=complex)

    for k in range(N):
        Z[k] = np.sum(signal * np.exp(-1j * 2 * np.pi * k * np.arange(N) / N))

    return Z


# Define the signal (2)^n u(n)
n = np.arange(10)  # Indices
signal = 2**n * (n >= 0)  # (2)^n u(n)

# Perform Z-transform
Z = z_transform_signal(signal)

# Plotting ROC
fig, ax = plt.subplots()
circle = plt.Circle((0, 0), radius=np.max(np.abs(Z)), edgecolor='r', facecolor='none')
ax.add_patch(circle)
plt.xlim(-np.max(np.abs(Z))-1, np.max(np.abs(Z))+1)
plt.ylim(-np.max(np.abs(Z))-1, np.max(np.abs(Z))+1)
plt.xlabel('Real')
plt.ylabel('Imaginary')
plt.title('Region of Convergence (ROC)')
plt.grid(True, linestyle='--', linewidth=0.5)
plt.gca().set_aspect('equal', adjustable='box')
plt.show()


# Printing Z-transform values
print("Z-transform values:")
for i, z in enumerate(Z):
    print("Z[{}]: {}".format(i, z))

import numpy as np
import matplotlib.pyplot as plt

def z_transform_signal(signal):

    N = len(signal)
    Z = np.zeros(N, dtype=complex)

    for k in range(N):
        Z[k] = np.sum(signal * np.exp(-1j * 2 * np.pi * k * np.arange(N) / N))

    roc = "ROC: |Z| < 1/2"

    return Z, roc

# Define the signal (0.5)^(nu(-n-1))
n = np.arange(-10, 11)  # Indices
signal = (0.5)**(n) * (n < 0)  # (0.5)^(nu(-n-1))

# Perform Z-transform
Z, roc = z_transform_signal(signal)

# Plotting ROC
fig, ax = plt.subplots()
circle = plt.Circle((0, 0), radius=1/2, edgecolor='r', facecolor='none')
ax.add_patch(circle)
plt.xlim(-1, 1)
plt.ylim(-1, 1)
plt.xlabel('Real')
plt.ylabel('Imaginary')
plt.title('Region of Convergence (ROC)')
plt.grid(True, linestyle='--', linewidth=0.5)
plt.gca().set_aspect('equal', adjustable='box')
plt.show()

# Printing Z-transform values
print("Z-transform values:")
for i, z in enumerate(Z):
    print("Z[{}]: {}".format(i, z))

# Printing ROC
print("\nRegion of Convergence:")
print(roc)

"""#**DSP LAB 04**    (Fourier-Series)"""

import numpy as np
import matplotlib.pyplot as plt

def calculate_fourier_series_coefficients(f, T, N):

    coefficients = np.zeros(N, dtype=np.complex)

    t = np.linspace(0, T, num=1000)
    dt = t[1] - t[0]

    for n in range(N):
        integrand = f(t) * np.exp(-1j * 2 * np.pi * n * t / T)
        coefficients[n] = (1 / T) * np.sum(integrand) * dt

    return coefficients

def reconstruct_from_fourier_series(coefficients, T, t):

    N = len(coefficients)
    reconstructed = np.zeros_like(t, dtype=np.complex)

    for n in range(N):
        reconstructed += coefficients[n] * np.exp(1j * 2 * np.pi * n * t / T)

    return reconstructed

# Sample function
def f(t):
    return np.sin(2 * np.pi * t) + 0.5 * np.sin(6 * np.pi * t)

# Period and number of coefficients
T = 1.0
N = 10

# Calculate Fourier series coefficients
coefficients = calculate_fourier_series_coefficients(f, T, N)

# Time points for plotting
t = np.linspace(0, T, num=1000)

# Original function
original = f(t)

# Reconstructed function
reconstructed = reconstruct_from_fourier_series(coefficients, T, t)

# Plotting
plt.plot(t, original, label='Original Function')
plt.plot(t, reconstructed.real, '--', label='Reconstructed Function')
plt.xlabel('Time')
plt.ylabel('Amplitude')
plt.legend()
plt.grid(True)
plt.show()

def calculate_energy_density_spectrum(coefficients):

    spectrum = np.abs(coefficients) ** 2
    return spectrum

# Calculate the energy density spectrum
energy_spectrum = calculate_energy_density_spectrum(coefficients)

# Frequency values for plotting
frequencies = np.fft.fftfreq(N, d=T/N)

# Plotting the energy density spectrum
plt.stem(frequencies, energy_spectrum, use_line_collection=True)
plt.xlabel('Frequency')
plt.ylabel('Energy Density')
plt.grid(True)
plt.show()

#Tasks

"""#**DSP LAB 05**   (Fourier_Transformation DFT & DTFT)"""

import numpy as np
import matplotlib.pyplot as plt

def dft(x):
    N = len(x)
    X = np.zeros(N, dtype=complex)

    for k in range(N):
        for n in range(N):
            X[k] += x[n] * np.exp(-2j * np.pi * k * n / N)

    return X

# Input sequence
x = np.array([1, 1, 0, 0])

# Compute DFT
X = dft(x)


# Compute magnitude and phase spectra
magnitude = np.abs(X)
phase = np.angle(X)

# Plotting
plt.figure(figsize=(10, 4))

plt.subplot(1, 2, 1)
plt.stem(np.arange(len(x)), x, use_line_collection=True)
plt.xlabel('n')
plt.ylabel('x(n)')
plt.title('Input Sequence')

plt.subplot(1, 2, 2)
plt.stem(np.arange(len(magnitude)), magnitude, use_line_collection=True)
plt.xlabel('k')
plt.ylabel('|X(k)|')
plt.title('Magnitude Spectrum')

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

def dtft(x, a, omega):
    N = len(x)  # Length of the input sequence
    X = np.zeros(len(omega), dtype=complex)  # Array to store the DTFT values

    for k in range(len(omega)):
        for n in range(N):
            X[k] += x[n] * np.exp(-1j * omega[k] * n)

    return X


# Input sequence parameters
a = 0.9
n = np.arange(-10, 11)
x = a ** n

# DTFT parameters
omega = np.linspace(-np.pi, np.pi, 1000)
# Compute DTFT
X = dtft(x, a, omega)

# Compute magnitude and phase spectra
magnitude = np.abs(X)
phase = np.angle(X)

# Plotting
plt.figure(figsize=(10, 4))

plt.subplot(1, 2, 1)
plt.plot(n, x)
plt.xlabel('n')
plt.ylabel('x(n)')
plt.title('Input Sequence')

plt.subplot(1, 2, 2)
plt.plot(omega, magnitude)
plt.xlabel('Omega')
plt.ylabel('|X(omega)|')
plt.title('Magnitude Spectrum')

plt.tight_layout()
plt.show()

"""#**DSP LAB 06**  (Frequency Separation from Audio Signal)"""

! pip install pydub

from pydub import AudioSegment
import numpy as np
import matplotlib.pyplot as plt
from scipy.fft import fft

# Load audio signal
path = "/content/drive/MyDrive/Colab Notebooks/veer-zaara.mp3"
audio = AudioSegment.from_file(path, format="mp3")
samples = np.array(audio.get_array_of_samples())
fs = audio.frame_rate

# Perform FFT
fft_out = fft(samples)

# Plot the frequency spectrum
magnitude = np.abs(fft_out)
frequency = np.linspace(0, fs, len(magnitude))

plt.plot(frequency, magnitude)
plt.xlabel("Frequency (Hz)")
plt.ylabel("Amplitude")
plt.show()

# Define the frequency range for each fundamental frequency
fundamental_frequencies = [100, 200, 300, 400, 500]
frequency_ranges = [(f - 10, f + 10) for f in fundamental_frequencies]

# Separate the different frequencies
frequency_components = []
for low, high in frequency_ranges:
    index_range = np.logical_and(frequency >= low, frequency <= high)
    frequency_component = magnitude[index_range]
    frequency_components.append(frequency_component)

# Output each of the fundamental frequencies
for i, (low, high) in enumerate(frequency_ranges):
    component = frequency_components[i]
    index_max = np.argmax(component)
    frequency_max = frequency[index_max]
    amplitude_max = component[index_max]
    print(f"Fundamental frequency {i + 1}: {frequency_max:.2f} Hz (amplitude {amplitude_max:.2f})")

import librosa
import numpy as np
import pydub
from scipy.io.wavfile import write

# Load .mp3 file
path = "/content/drive/MyDrive/Colab Notebooks/veer-zaara.mp3"
audio = AudioSegment.from_file(path, format="mp3")
# Save .wav file
wav_filename = "audio_signal.wav"
audio.export(wav_filename, format="wav")

# Load .wav file
samples, sr = librosa.load(wav_filename)

# Perform Short-Time Fourier Transform (STFT)
stft = np.abs(librosa.stft(samples))

# Define the frequency ranges for the vocal, bass, and lead
vocal_range = (100, 300)
bass_range = (20, 100)
lead_range = (300, 5000)

# Separate the different frequency components
vocal_stft = stft.copy()
vocal_stft[(stft <= vocal_range[0]) | (stft > vocal_range[1])] = 0

bass_stft = stft.copy()
bass_stft[(stft <= bass_range[0]) | (stft > bass_range[1])] = 0

lead_stft = stft.copy()
lead_stft[(stft <= lead_range[0]) | (stft > lead_range[1])] = 0

# Convert the STFTs back to the time domain
vocal = librosa.istft(vocal_stft)
bass = librosa.istft(bass_stft)
lead = librosa.istft(lead_stft)

# Output each of the separated signals
write("vocal.wav", sr, vocal)
write("bass.wav", sr, bass)
write("lead.wav", sr, lead)